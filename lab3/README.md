# Design Decisions for L2

In L2, we modified our L1 compiler so that it will handle codes involving control flow as well as adding more operations involving both integer types and boolean types. In order to do so, we have modified all aspects of the compiler to compile
our new language as specified in the steps below.

## Overall Workflow

**C0 Code** ---Lexer/Parser---> **AST** ---Elaboration---> **EAST** ---TypeChecking & Optimization--> **EAST** ---Translation---> **Abstract Assembly** ---Live Analysis & Register Allocation---> **Assembly** ---CodeGen---> **x86-64**

## Lexing and Parsing

For Lexing, we added the tokens used in our new language that represents our control flow (if, while) and other arithmetic and boolean operations that we did not have before(<=,>, >> etc.). We also added the boolean type.

For Parsing, we have changed our language to the specification for L2 as specified in lecture notes, adding control flow and ternary operations and the operation precedences accordingly. To resolve the shift reduce and reduce reduce errors provided by if else and exp, lval assignment, we made the following decisions:

- making if else right associative, thus making else always going with the closest if.
- deleting lval, classifying everything as Exp and let the parser only parse during assignment if the Exp represents variable ident.

## Elaboraton

For Elaboration, we modified our AST representation generated by our parsing into an IR called EAST. EAST consists of the following types similarly to described in the lab handout:

```
data EAST 
    = ESeq EAST EAST
    | EAssign Ident EExp
    | EIf EExp EAST EAST
    | EWhile EExp EAST
    | ERet EExp
    | ENop
    | EDecl Ident Type EAST
    | ELeaf EExp
```

Specifically, we have EDecl having precedence of ESeq when converting an statment block that containing variable declarations in the block to fascilitate type checking for variable scopes. 

ENop is used for the case we have an empty block in while statements or empty else statement.

We treat Exps are Leafs of our EAST into a new data type called EExp for subsequent steps of the compiler. The type for EExp is listed below:

```
data EExp
    = EInt Int
    | ET
    | EF
    | EIdent Ident
    | EBinop Binop EExp EExp
    | ETernop EExp EExp EExp
    | EUnop Unop EExp
    deriving Eq
```

## Typechecking

Typechecking consists of three parts:

**Static Type Checking**: Check that the static semantics of statements and expressions are satisfied. This is done by maintaining a typing context, and recursively check that the static semantics are met. If typing violations are found, the compiler will raise `Tycon mismatch`.

**Proper Return Checking**: Check that all finite control flow paths through the program starting at the beginning of each function, end with an explicit `return` statement. If violations are found, the compiler will raise `Main does not return`.

**Checking Variable Initialization**: Check that along all control flow paths, any variable is defined before use. This is done by maintaing a set of declared variables and a set of defined variables of a scope.  If violations are found, the compiler will raise `Variable used before initialization`.

## Constant Folding Optimizations
After Typechecking, we went through another iteration of our EAST to simplify statements that only contains constants. Specifically, when a binop expression having only constants, we simplify the binop expression by evaluating it directly.

## Liveness and interference graph
For liveness analysis, we changed the structure completely to accommodate control flow. We first created a map of all labels to their line numbers, then we went through all the lines for a map that maps each line to their corresponding with the label locations known.

    (defined variable set, successor list, used variable set)

From this information we have, we created a map of predecessor set for each line to help us in our liveness computation going upwards.

Now, we computed the live variable by the method of going through each used variable on each line adding it to the line's useset. We look upwards until we reached the end (no predecessors), found the variable being in the def set, or found the variable is in the liveset of one of its predecessors (which means we have already did all the predecessors of this line before). After we reached the very top (line 1) of our IR, we know we have looked through all the possible ways of variable being live, and we are done.

In terms of interference, the rule for L1 remains the same, but we need to change l+1 to successor list. Thus we implemented interference graph by the following rule below:
```
l: x <- exp
live(any(l' in succ(l)), u)  =>  interfere(x, u)
x != u
```
Coloring and register allocation remains the same, we just needed to consider the special case where we have lshift or rshift, which we need to precolor rcx by the assembly rule.

## EAST -> Abstract Assembly

We follow the dynamic semantics in (http://www.cs.cmu.edu/afs/cs/academic/class/15411-f19/www/lec/09b-irtrees.pdf).

We use the `State` monad to keep track of the fresh variables and labels.

```
data Alloc =
    Alloc
        { variables :: Map.Map String Int
    -- ^ Map from source variable names to unique variable ids.
        , uniqueIDCounter :: Int
    -- ^ Value greater than any id in the map.
        , uniqueLabelCounter :: Int
    -- ^ Next label to generate.
        }
```

We define several types of abstract assembly constructors to handle control flows:

```
data ACtrl
  = ALab ALabel   -- Label
  | AJump ALabel    -- Direct Jump
  | ACJump AVal ALabel ALabel   -- Conditional Jump, if x then l1 else l2
  | ACJump' ARelOp AVal AVal ALabel ALabel  -- Conditional Jump, if (x ? y) then l1 else l2
```

## Abstract Assembly -> Assembly

### Define Assembly

For L2 compiler, we add in `Jmp, Je, Label, Cmp ...` to handle control flow. We also add in some new x86 instructions for boolean and int types.

```
data  Inst
= Movl Operand Operand
| Movabsq Int Operand
| Addl Operand Operand
| Subl Operand Operand
| Imull Operand Operand
| Idivl Operand
| Sall Int Operand
| Sarl Int Operand
| Negl Operand
| Pushq Operand
| Popq Operand
| Cdq
| Cqto
| Ret
| Andl Operand Operand
| Orl Operand Operand
| Xorl Operand Operand
| Notl Operand
| Label String
| Cmp Operand Operand
| Jmp String
| Je String
...

data  Operand
= Imm Int
| Reg Register
| Mem
    { imm ::  Int
    , base ::  Register
    , index ::  Register
    , width ::  Int
    }
| Mem'
    { imm ::  Int
    , base ::  Register
    } deriving (Eq, Ord)

data  Register -- 16 64-bit registers & 16 32-bit registers
```

From the data type definition, we know that an operand is either an Immediate, a Register, or some data stored in a memory location. We can refer to an address in memory using `Mem{imm, base, idx, w} = $imm(%base, %idx, w)` or using `Mem'{imm, base} = $imm(%base)`.

We decide to include both 64-bit and 32-bit registers, and define a function `toReg64` to convert a 32-bit register to a 64-bit register.

The code generation from abstract assembly to assembly is based on pattern-matching on abstract assembly. There are some special cases to consider:

- We reserve register `%R11 / %R11D` for moves to and from the stack when necessary. For example, the abstract assembly `16(%RSP) <- 8(%RSP) + $5` may be translated to a sequence `[movq 8(%RSP) %R11, addq $5 %R11, movq R11 16(%RSP)]`.

- For `Idiv / Imod`, we need to reserve `%RAX` and `RDX` for this special use case. Since we have already made `%RAX` and `RDX` interfere with the operands, and precolored `%RAX` and `RDX` with the desired registers, we are sure that moving operands into `%RAX` and `RDX` is safe.

- Similarly, for `Sall / Sarl`, we need to reserve `RCX` for the special use case.

To make the generated x86 assembly more compact, the compiler will

- Remove trivial instructions, e.g. `Movq %RAX %RAX`
- Remove unreachable code blocks
