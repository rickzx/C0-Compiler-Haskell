# README
 * Author: Frank Pfenning <fp@cs.cmu.edu>
 * Modified: Anand Subramanian <asubrama@andrew.cmu.edu>
 * Modified for Haskell: Rokhini Prabhu <rokhinip@andrew.cmu.edu>

-----------------------------------------------------------------------
Welcome to 15-411!
-----------------------------------------------------------------------

This is some starter code for the L1 compiler you have to build for
the Lab1.  It contains a lexer, parser, translator, and even a code
generator, except that the code generator creates pseudo assembly
language with fictitious instructions and an unlimited number of
registers.  We took some care to use good style (according to the
instructor); you may consider this a model for your own coding.  Feel
free to modify any and all of this code as you see fit.

Bug reports to the course staff are particularly welcome and will be
noted in the extra credit category.

-----------------------------------------------------------------------
Haskell Notes
-----------------------------------------------------------------------

This starter code assumes GHC 8.6.5, which is the version on the Docker
image (and hence the autograder).

It bears mentioning that, to use `ghc` and `ghci` on the Docker image,
you can run commands like:

```
$ stack exec -- ghci
$ stack exec -- ghc
```

From within your project, you can just run `stack ghci` to spin up a
REPL with access to the modules you wrote.

------------------------------------------------------------------------
Source Files
------------------------------------------------------------------------
The following are the source files for the L1 compiler

```
README               -- this file

c0c.cabal            -- This is the configuration for the standard package
                        system for Haskell software.
Makefile             -- makefile for the compiler
                        For a quick test

    % make              (generates file bin/c0c)
    % bin/c0c ../../tests/l1-basic/return01.l1
            (generates ../../tests/l1-basic/return01.l1.abs in pseudo assembly)

    % make clean        (removes generated files)

bin/c0c              -- the native executable generated by Haskell

src/                Source code for the compiler
    c0c.hs              This is effectively main() function for your
                        compiler
    Compile.hs          This does all the steps necessary in your compiler
                        - from parsing till writng out assembly to a file
    Args.hs             Parses command line arguments
    LiftIOE.hs          Utility helper functions
    Util.hs             Utility helper functions

Compile/
    Lexer.x             lexer (based on Alex, generates Lexer.hs)
    Parser.y            parser (based on Happy, generates Parser.y)
    CheckAST.hs         typechecker
    CodeGen.hs          code generation - conversion to abstract assembly
    Types.hs            includes all the types specified in Types/ folder

    Types/                  Includes the data structures and types used
                            in the code in Compile/
        AST.hs              Abstract Syntax Tree from parsing
        AbstractAssembly.hs The assembly produced by code generation
        Ops.hs              The binops and monops used in AST and
                            AbstractAssembly
        Jobs.hs             Each source code file you parse is its own job

    Backend/                Our implementation of Backend for L1, consists of  
                            live variable calculation, interference graph building, 
                            and register allocation based on MCS coloring 
                            on a Single Elimination Order. Finally, we converted 
                            the AASM given after parsing into assembly language
                            for the program to compile.

        LiveVariable.hs     Live Variable Calculation and interference graph
        RegisterAlloc.hs    Performing MCS coloring and register allocation
        AAsm2Asm.hs         Converting the Abstract Assembly to Assembly language, 
                            assigning registers according to thecoloring 
                            scheme by MCS.
                    
```
________________________________________________________________________________
# Design decisions for L1:

## prehandling

    To optimize our compiler in time efficiency, before calculation on the liveness
    and interference graph, we first check the number of temps needed 
    for the input code during our code generation, if its more than a set number, we
    ignore the register allocation process, spilling all the temps on to the
    stack.

## liveness and interference graph

    When calculating live variables, we reverse the tree by starting from return 
    statement and going upwards, and storing the live variables in each line as
    a list of sets. The live variables is defined by

        currentInUse union liveAfter union assignedLineBefore \\ currentAssigned

    If we have division, we also say rax and rdx are live due to its special use

    After completing the live variable, we build our interference relationship
    based on the rule that 

        l: x <- exp
        live(l+1, u)  =>  interfere(x, u)
        x != u
    
    Then, for assignments in each line, we look at the livevariables in the line 
    immediately after it, and the variable in the assignment will interferes with 
    all the variables in the line immediately afterwards by our interfere rule.

    Our interference graph is designed as a Map structure that map each ALoc to its 
    interference set, for each line, we insert the interfered variables to the 
    corresponding interefence set of ALoc being assigned.

## Register Allocation

    After we have formed our interference graph, we color the graph based on MCS
    algorithm, which outputs an Single Elimination ordering. To do so, we utilizes a 
    priority queue structure, each time outputs the variable with the largest value, 
    which is incremented everytime one of its neighbor in the interference graph 
    gets picked in the SEO.

    Before we color in SEO, we first precolor Rax and Rdx, so that they are always 
    ready when needed in division.

    Then, we perform coloring in the SEO, giving each temp the lowest color possible 
    computed by looking through its neighbor list. We then maps each color to the 
    corresponding register. For the temps having color > total registers available, we perform
    spilling, which allocate the temp onto the stack space instead. When compiling, 
    we would first move rsp down the correspoding number of temps * 8 byte space to store
    them.

## Deadcode Removal

    Before we convert to assembly, we also removed redundant code, such as the statements
    after return, and Mov from a register to the same register.

## Abstract Assembly -> Assembly

### Define Assembly

    For L1 compiler, we define the following data type for x86-64 assembly, which is sufficient 
    for generating result for straight-line code.

    ```
    data  Inst
    = Movq Operand Operand
    | Movl Operand Operand
    | Movabsq Int Operand
    | Addq Operand Operand
    | Addl Operand Operand
    | Subq Operand Operand
    | Subl Operand Operand
    | Imulq Operand Operand
    | Imull Operand Operand
    | Idivq Operand
    | Idivl Operand
    | Salq Int Operand
    | Sall Int Operand
    | Sarq Int Operand
    | Sarl Int Operand
    | Negq Operand
    | Negl Operand
    | Pushq Operand
    | Popq Operand
    | Cdq
    | Cqto
    | Ret

    data  Operand
    = Imm Int
    | Reg Register
    | Mem
        { imm ::  Int
        , base ::  Register
        , index ::  Register
        , width ::  Int
        }
    | Mem'
        { imm ::  Int
        , base ::  Register
        } deriving (Eq, Ord)

    data  Register -- 16 64-bit registers & 16 32-bit registers
    ```

    From the data type definition, we know that an operand is either an Immediate, a Register,
    or some data stored in a memory location. We can refer to an address in memory using 
    `Mem{imm, base, idx, w} = $imm(%base, %idx, w)` or using `Mem'{imm, base} = $imm(%base)`.

    We decide to include both 64-bit and 32-bit registers, and define a function `toReg64` to 
    convert a 32-bit register to a 64-bit register.

    The code generation from abstract assembly to assembly is based on pattern-matching on 
    abstract assembly. There are some special cases to consider:

    - We reserve register `%R11 / %R11D` for moves to and from the stack when necessary. 
    For example, the abstract assembly `16(%RSP) <- 8(%RSP) + $5` may be translated to a sequence 
    `[movq 8(%RSP) %R11, addq $5 %R11, movq R11 16(%RSP)]`.

    - For `Idiv / Imod`, we need to reserve `%RAX` and `RDX` for this special use case. Since we
    have already made `%RAX` and `RDX` interfere with the operands, and precolored `%RAX` and 
    `RDX` with the desired registers, we are sure that moving operands into `%RAX` and `RDX` is safe.

    To make the generated x86 assembly more compact, the compiler will

    - Remove trivial instructions, e.g. `Movq %RAX %RAX`
    - Remove unreachable code blocks, e.g. everything after `Ret`





