#Design Decisions for L2

In L2, we modified our L1 compiler so that it will handle codes involving control flow as well as adding more operations involving both integer types and boolean types. In order to do so, we have modified all aspects of the compiler to compile
our new language as specified in the steps below.

##Lexing and Parsing

For Lexing, we added the tokens used in our new language that represents our control flow (if, while) and other arithmetic and boolean operations that we did not have before(<=,>, >> etc.). We also added the boolean type.

For Parsing, we have changed our language to the specification for L2 as specified in lecture notes, adding control flow and ternary operations and the operation precedences accordingly. To resolve the shift reduce and reduce reduce errors provided by if else and exp, lval assignment, we made the following decisions:

- making if else right associative, thus making else always going with the closest if.
- deleting lval, classifying everything as Exp and let the parser only parse during assignment if the Exp represents variable ident.

##Elaboraton

For Elaboration, we modified our AST representation generated by our parsing into an IR called EAST. EAST consists of the following types similarly to described in the lab handout:

data EAST 
    = ESeq EAST EAST
    | EAssign Ident EExp
    | EIf EExp EAST EAST
    | EWhile EExp EAST
    | ERet EExp
    | ENop
    | EDecl Ident Type EAST
    | ELeaf EExp

Specifically, we have EDecl having precedence of ESeq when converting an statment block that containing variable declarations in the block to fascilitate type checking for variable scopes. 

ENop is used for the case we have an empty block in while statements or empty else statement.

We treat Exps are Leafs of our EAST into a new data type called EExp for subsequent steps of the compiler. The type for EExp is listed below:

data EExp
    = EInt Int
    | ET
    | EF
    | EIdent Ident
    | EBinop Binop EExp EExp
    | ETernop EExp EExp EExp
    | EUnop Unop EExp
    deriving Eq

##Typechecking

##Constant Folding Optimizations
After Typechecking, we went through another iteration of our EAST to simplify statements that only contains constants. Specifically, when a binop expression having only constants, we simplify the binop expression by evaluating it directly.

##Liveness and interference graph
For liveness analysis, we changed the structure completely to accommodate control flow. We first created a map of all labels to their line numbers, then we went through all the lines for a map that maps each line to their corresponding with the label locations known.

    (defined variable set, successor list, used variable set)

From this information we have, we created a map of predecessor set for each line to help us in our liveness computation going upwards.

Now, we computed the live variable by the method of going through each used variable on each line adding it to the line's useset. We look upwards until we reached the end (no predecessors), found the variable being in the def set, or found the variable is in the liveset of one of its predecessors (which means we have already did all the predecessors of this line before). After we reached the very top (line 1) of our IR, we know we have looked through all the possible ways of variable being live, and we are done.

In terms of interference, the rule for L1 remains the same, but we need to change l+1 to successor list. Thus we implemented interference graph by the following rule below:

l: x <- exp
live(any(l' in succ(l)), u)  =>  interfere(x, u)
x != u

Coloring and register allocation remains the same, we just needed to consider the special case where we have lshift or rshift, which we need to precolor rcx by the assembly rule.

## Abstract Assembly -> Assembly

### Define Assembly

For L2 compiler, we define the following data type for x86-64 assembly, which is sufficient for generating result for straight-line code.

```
data  Inst
= Movq Operand Operand
| Movl Operand Operand
| Movabsq Int Operand
| Addq Operand Operand
| Addl Operand Operand
| Subq Operand Operand
| Subl Operand Operand
| Imulq Operand Operand
| Imull Operand Operand
| Idivq Operand
| Idivl Operand
| Salq Int Operand
| Sall Int Operand
| Sarq Int Operand
| Sarl Int Operand
| Negq Operand
| Negl Operand
| Pushq Operand
| Popq Operand
| Cdq
| Cqto
| Ret

data  Operand
= Imm Int
| Reg Register
| Mem
    { imm ::  Int
    , base ::  Register
    , index ::  Register
    , width ::  Int
    }
| Mem'
    { imm ::  Int
    , base ::  Register
    } deriving (Eq, Ord)

data  Register -- 16 64-bit registers & 16 32-bit registers
```

From the data type definition, we know that an operand is either an Immediate, a Register, or some data stored in a memory location. We can refer to an address in memory using `Mem{imm, base, idx, w} = $imm(%base, %idx, w)` or using `Mem'{imm, base} = $imm(%base)`.

We decide to include both 64-bit and 32-bit registers, and define a function `toReg64` to convert a 32-bit register to a 64-bit register.

The code generation from abstract assembly to assembly is based on pattern-matching on abstract assembly. There are some special cases to consider:

- We reserve register `%R11 / %R11D` for moves to and from the stack when necessary. For example, the abstract assembly `16(%RSP) <- 8(%RSP) + $5` may be translated to a sequence `[movq 8(%RSP) %R11, addq $5 %R11, movq R11 16(%RSP)]`.

- For `Idiv / Imod`, we need to reserve `%RAX` and `RDX` for this special use case. Since we have already made `%RAX` and `RDX` interfere with the operands, and precolored `%RAX` and `RDX` with the desired registers, we are sure that moving operands into `%RAX` and `RDX` is safe.

To make the generated x86 assembly more compact, the compiler will

- Remove trivial instructions, e.g. `Movq %RAX %RAX`
- Remove unreachable code blocks, e.g. everything after `Ret`
